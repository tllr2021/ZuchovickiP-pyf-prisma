// Code generated by Prisma (prisma@1.34.12). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  cine: (where?: CineWhereInput) => Promise<boolean>;
  colaborator: (where?: ColaboratorWhereInput) => Promise<boolean>;
  movie: (where?: MovieWhereInput) => Promise<boolean>;
  ordenDulceria: (where?: OrdenDulceriaWhereInput) => Promise<boolean>;
  pago: (where?: PagoWhereInput) => Promise<boolean>;
  room: (where?: RoomWhereInput) => Promise<boolean>;
  seat: (where?: SeatWhereInput) => Promise<boolean>;
  ticket: (where?: TicketWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  cine: (where: CineWhereUniqueInput) => CineNullablePromise;
  cines: (args?: {
    where?: CineWhereInput;
    orderBy?: CineOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Cine>;
  cinesConnection: (args?: {
    where?: CineWhereInput;
    orderBy?: CineOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CineConnectionPromise;
  colaborator: (
    where: ColaboratorWhereUniqueInput
  ) => ColaboratorNullablePromise;
  colaborators: (args?: {
    where?: ColaboratorWhereInput;
    orderBy?: ColaboratorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Colaborator>;
  colaboratorsConnection: (args?: {
    where?: ColaboratorWhereInput;
    orderBy?: ColaboratorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ColaboratorConnectionPromise;
  movie: (where: MovieWhereUniqueInput) => MovieNullablePromise;
  movies: (args?: {
    where?: MovieWhereInput;
    orderBy?: MovieOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Movie>;
  moviesConnection: (args?: {
    where?: MovieWhereInput;
    orderBy?: MovieOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MovieConnectionPromise;
  ordenDulceria: (
    where: OrdenDulceriaWhereUniqueInput
  ) => OrdenDulceriaNullablePromise;
  ordenDulcerias: (args?: {
    where?: OrdenDulceriaWhereInput;
    orderBy?: OrdenDulceriaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<OrdenDulceria>;
  ordenDulceriasConnection: (args?: {
    where?: OrdenDulceriaWhereInput;
    orderBy?: OrdenDulceriaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OrdenDulceriaConnectionPromise;
  pago: (where: PagoWhereUniqueInput) => PagoNullablePromise;
  pagoes: (args?: {
    where?: PagoWhereInput;
    orderBy?: PagoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Pago>;
  pagoesConnection: (args?: {
    where?: PagoWhereInput;
    orderBy?: PagoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PagoConnectionPromise;
  room: (where: RoomWhereUniqueInput) => RoomNullablePromise;
  rooms: (args?: {
    where?: RoomWhereInput;
    orderBy?: RoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Room>;
  roomsConnection: (args?: {
    where?: RoomWhereInput;
    orderBy?: RoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RoomConnectionPromise;
  seat: (where: SeatWhereUniqueInput) => SeatNullablePromise;
  seats: (args?: {
    where?: SeatWhereInput;
    orderBy?: SeatOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Seat>;
  seatsConnection: (args?: {
    where?: SeatWhereInput;
    orderBy?: SeatOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SeatConnectionPromise;
  ticket: (where: TicketWhereUniqueInput) => TicketNullablePromise;
  tickets: (args?: {
    where?: TicketWhereInput;
    orderBy?: TicketOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Ticket>;
  ticketsConnection: (args?: {
    where?: TicketWhereInput;
    orderBy?: TicketOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TicketConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCine: (data: CineCreateInput) => CinePromise;
  updateCine: (args: {
    data: CineUpdateInput;
    where: CineWhereUniqueInput;
  }) => CinePromise;
  updateManyCines: (args: {
    data: CineUpdateManyMutationInput;
    where?: CineWhereInput;
  }) => BatchPayloadPromise;
  upsertCine: (args: {
    where: CineWhereUniqueInput;
    create: CineCreateInput;
    update: CineUpdateInput;
  }) => CinePromise;
  deleteCine: (where: CineWhereUniqueInput) => CinePromise;
  deleteManyCines: (where?: CineWhereInput) => BatchPayloadPromise;
  createColaborator: (data: ColaboratorCreateInput) => ColaboratorPromise;
  updateColaborator: (args: {
    data: ColaboratorUpdateInput;
    where: ColaboratorWhereUniqueInput;
  }) => ColaboratorPromise;
  updateManyColaborators: (args: {
    data: ColaboratorUpdateManyMutationInput;
    where?: ColaboratorWhereInput;
  }) => BatchPayloadPromise;
  upsertColaborator: (args: {
    where: ColaboratorWhereUniqueInput;
    create: ColaboratorCreateInput;
    update: ColaboratorUpdateInput;
  }) => ColaboratorPromise;
  deleteColaborator: (where: ColaboratorWhereUniqueInput) => ColaboratorPromise;
  deleteManyColaborators: (
    where?: ColaboratorWhereInput
  ) => BatchPayloadPromise;
  createMovie: (data: MovieCreateInput) => MoviePromise;
  updateMovie: (args: {
    data: MovieUpdateInput;
    where: MovieWhereUniqueInput;
  }) => MoviePromise;
  updateManyMovies: (args: {
    data: MovieUpdateManyMutationInput;
    where?: MovieWhereInput;
  }) => BatchPayloadPromise;
  upsertMovie: (args: {
    where: MovieWhereUniqueInput;
    create: MovieCreateInput;
    update: MovieUpdateInput;
  }) => MoviePromise;
  deleteMovie: (where: MovieWhereUniqueInput) => MoviePromise;
  deleteManyMovies: (where?: MovieWhereInput) => BatchPayloadPromise;
  createOrdenDulceria: (data: OrdenDulceriaCreateInput) => OrdenDulceriaPromise;
  updateOrdenDulceria: (args: {
    data: OrdenDulceriaUpdateInput;
    where: OrdenDulceriaWhereUniqueInput;
  }) => OrdenDulceriaPromise;
  updateManyOrdenDulcerias: (args: {
    data: OrdenDulceriaUpdateManyMutationInput;
    where?: OrdenDulceriaWhereInput;
  }) => BatchPayloadPromise;
  upsertOrdenDulceria: (args: {
    where: OrdenDulceriaWhereUniqueInput;
    create: OrdenDulceriaCreateInput;
    update: OrdenDulceriaUpdateInput;
  }) => OrdenDulceriaPromise;
  deleteOrdenDulceria: (
    where: OrdenDulceriaWhereUniqueInput
  ) => OrdenDulceriaPromise;
  deleteManyOrdenDulcerias: (
    where?: OrdenDulceriaWhereInput
  ) => BatchPayloadPromise;
  createPago: (data: PagoCreateInput) => PagoPromise;
  updatePago: (args: {
    data: PagoUpdateInput;
    where: PagoWhereUniqueInput;
  }) => PagoPromise;
  updateManyPagoes: (args: {
    data: PagoUpdateManyMutationInput;
    where?: PagoWhereInput;
  }) => BatchPayloadPromise;
  upsertPago: (args: {
    where: PagoWhereUniqueInput;
    create: PagoCreateInput;
    update: PagoUpdateInput;
  }) => PagoPromise;
  deletePago: (where: PagoWhereUniqueInput) => PagoPromise;
  deleteManyPagoes: (where?: PagoWhereInput) => BatchPayloadPromise;
  createRoom: (data: RoomCreateInput) => RoomPromise;
  updateRoom: (args: {
    data: RoomUpdateInput;
    where: RoomWhereUniqueInput;
  }) => RoomPromise;
  updateManyRooms: (args: {
    data: RoomUpdateManyMutationInput;
    where?: RoomWhereInput;
  }) => BatchPayloadPromise;
  upsertRoom: (args: {
    where: RoomWhereUniqueInput;
    create: RoomCreateInput;
    update: RoomUpdateInput;
  }) => RoomPromise;
  deleteRoom: (where: RoomWhereUniqueInput) => RoomPromise;
  deleteManyRooms: (where?: RoomWhereInput) => BatchPayloadPromise;
  createSeat: (data: SeatCreateInput) => SeatPromise;
  updateSeat: (args: {
    data: SeatUpdateInput;
    where: SeatWhereUniqueInput;
  }) => SeatPromise;
  updateManySeats: (args: {
    data: SeatUpdateManyMutationInput;
    where?: SeatWhereInput;
  }) => BatchPayloadPromise;
  upsertSeat: (args: {
    where: SeatWhereUniqueInput;
    create: SeatCreateInput;
    update: SeatUpdateInput;
  }) => SeatPromise;
  deleteSeat: (where: SeatWhereUniqueInput) => SeatPromise;
  deleteManySeats: (where?: SeatWhereInput) => BatchPayloadPromise;
  createTicket: (data: TicketCreateInput) => TicketPromise;
  updateTicket: (args: {
    data: TicketUpdateInput;
    where: TicketWhereUniqueInput;
  }) => TicketPromise;
  updateManyTickets: (args: {
    data: TicketUpdateManyMutationInput;
    where?: TicketWhereInput;
  }) => BatchPayloadPromise;
  upsertTicket: (args: {
    where: TicketWhereUniqueInput;
    create: TicketCreateInput;
    update: TicketUpdateInput;
  }) => TicketPromise;
  deleteTicket: (where: TicketWhereUniqueInput) => TicketPromise;
  deleteManyTickets: (where?: TicketWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  cine: (
    where?: CineSubscriptionWhereInput
  ) => CineSubscriptionPayloadSubscription;
  colaborator: (
    where?: ColaboratorSubscriptionWhereInput
  ) => ColaboratorSubscriptionPayloadSubscription;
  movie: (
    where?: MovieSubscriptionWhereInput
  ) => MovieSubscriptionPayloadSubscription;
  ordenDulceria: (
    where?: OrdenDulceriaSubscriptionWhereInput
  ) => OrdenDulceriaSubscriptionPayloadSubscription;
  pago: (
    where?: PagoSubscriptionWhereInput
  ) => PagoSubscriptionPayloadSubscription;
  room: (
    where?: RoomSubscriptionWhereInput
  ) => RoomSubscriptionPayloadSubscription;
  seat: (
    where?: SeatSubscriptionWhereInput
  ) => SeatSubscriptionPayloadSubscription;
  ticket: (
    where?: TicketSubscriptionWhereInput
  ) => TicketSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type RoomOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "number_ASC"
  | "number_DESC"
  | "available_ASC"
  | "available_DESC";

export type CineOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "ingresosDulceria_ASC"
  | "ingresosDulceria_DESC"
  | "ingresosTickets_ASC"
  | "ingresosTickets_DESC"
  | "available_ASC"
  | "available_DESC";

export type ColaboratorOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "nomina_ASC"
  | "nomina_DESC"
  | "password_ASC"
  | "password_DESC"
  | "Area_ASC"
  | "Area_DESC"
  | "dias_ASC"
  | "dias_DESC"
  | "pago_ASC"
  | "pago_DESC"
  | "available_ASC"
  | "available_DESC";

export type MovieOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "time_ASC"
  | "time_DESC"
  | "rates_ASC"
  | "rates_DESC"
  | "director_ASC"
  | "director_DESC"
  | "available_ASC"
  | "available_DESC";

export type OrdenDulceriaOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "amount_ASC"
  | "amount_DESC";

export type PagoOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "nomina_ASC"
  | "nomina_DESC"
  | "pago_ASC"
  | "pago_DESC";

export type SeatOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "available_ASC"
  | "available_DESC";

export type TicketOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "price_ASC"
  | "price_DESC"
  | "pagoPuntos_ASC"
  | "pagoPuntos_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "name_ASC"
  | "name_DESC"
  | "points_ASC"
  | "points_DESC"
  | "cardStatus_ASC"
  | "cardStatus_DESC"
  | "available_ASC"
  | "available_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type CineWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface RoomWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  number?: Maybe<Int>;
  number_not?: Maybe<Int>;
  number_in?: Maybe<Int[] | Int>;
  number_not_in?: Maybe<Int[] | Int>;
  number_lt?: Maybe<Int>;
  number_lte?: Maybe<Int>;
  number_gt?: Maybe<Int>;
  number_gte?: Maybe<Int>;
  Movie?: Maybe<MovieWhereInput>;
  available?: Maybe<Boolean>;
  available_not?: Maybe<Boolean>;
  AND?: Maybe<RoomWhereInput[] | RoomWhereInput>;
}

export interface MovieWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  time?: Maybe<Int>;
  time_not?: Maybe<Int>;
  time_in?: Maybe<Int[] | Int>;
  time_not_in?: Maybe<Int[] | Int>;
  time_lt?: Maybe<Int>;
  time_lte?: Maybe<Int>;
  time_gt?: Maybe<Int>;
  time_gte?: Maybe<Int>;
  rates?: Maybe<String>;
  rates_not?: Maybe<String>;
  rates_in?: Maybe<String[] | String>;
  rates_not_in?: Maybe<String[] | String>;
  rates_lt?: Maybe<String>;
  rates_lte?: Maybe<String>;
  rates_gt?: Maybe<String>;
  rates_gte?: Maybe<String>;
  rates_contains?: Maybe<String>;
  rates_not_contains?: Maybe<String>;
  rates_starts_with?: Maybe<String>;
  rates_not_starts_with?: Maybe<String>;
  rates_ends_with?: Maybe<String>;
  rates_not_ends_with?: Maybe<String>;
  director?: Maybe<String>;
  director_not?: Maybe<String>;
  director_in?: Maybe<String[] | String>;
  director_not_in?: Maybe<String[] | String>;
  director_lt?: Maybe<String>;
  director_lte?: Maybe<String>;
  director_gt?: Maybe<String>;
  director_gte?: Maybe<String>;
  director_contains?: Maybe<String>;
  director_not_contains?: Maybe<String>;
  director_starts_with?: Maybe<String>;
  director_not_starts_with?: Maybe<String>;
  director_ends_with?: Maybe<String>;
  director_not_ends_with?: Maybe<String>;
  available?: Maybe<Boolean>;
  available_not?: Maybe<Boolean>;
  AND?: Maybe<MovieWhereInput[] | MovieWhereInput>;
}

export interface CineWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  Colaborator?: Maybe<ColaboratorWhereInput>;
  room_some?: Maybe<RoomWhereInput>;
  ingresosDulceria?: Maybe<Int>;
  ingresosDulceria_not?: Maybe<Int>;
  ingresosDulceria_in?: Maybe<Int[] | Int>;
  ingresosDulceria_not_in?: Maybe<Int[] | Int>;
  ingresosDulceria_lt?: Maybe<Int>;
  ingresosDulceria_lte?: Maybe<Int>;
  ingresosDulceria_gt?: Maybe<Int>;
  ingresosDulceria_gte?: Maybe<Int>;
  ingresosTickets?: Maybe<Int>;
  ingresosTickets_not?: Maybe<Int>;
  ingresosTickets_in?: Maybe<Int[] | Int>;
  ingresosTickets_not_in?: Maybe<Int[] | Int>;
  ingresosTickets_lt?: Maybe<Int>;
  ingresosTickets_lte?: Maybe<Int>;
  ingresosTickets_gt?: Maybe<Int>;
  ingresosTickets_gte?: Maybe<Int>;
  available?: Maybe<Boolean>;
  available_not?: Maybe<Boolean>;
  AND?: Maybe<CineWhereInput[] | CineWhereInput>;
}

export interface ColaboratorWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  nomina?: Maybe<String>;
  nomina_not?: Maybe<String>;
  nomina_in?: Maybe<String[] | String>;
  nomina_not_in?: Maybe<String[] | String>;
  nomina_lt?: Maybe<String>;
  nomina_lte?: Maybe<String>;
  nomina_gt?: Maybe<String>;
  nomina_gte?: Maybe<String>;
  nomina_contains?: Maybe<String>;
  nomina_not_contains?: Maybe<String>;
  nomina_starts_with?: Maybe<String>;
  nomina_not_starts_with?: Maybe<String>;
  nomina_ends_with?: Maybe<String>;
  nomina_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  Cine?: Maybe<CineWhereInput>;
  Area?: Maybe<String>;
  Area_not?: Maybe<String>;
  Area_in?: Maybe<String[] | String>;
  Area_not_in?: Maybe<String[] | String>;
  Area_lt?: Maybe<String>;
  Area_lte?: Maybe<String>;
  Area_gt?: Maybe<String>;
  Area_gte?: Maybe<String>;
  Area_contains?: Maybe<String>;
  Area_not_contains?: Maybe<String>;
  Area_starts_with?: Maybe<String>;
  Area_not_starts_with?: Maybe<String>;
  Area_ends_with?: Maybe<String>;
  Area_not_ends_with?: Maybe<String>;
  dias?: Maybe<Int>;
  dias_not?: Maybe<Int>;
  dias_in?: Maybe<Int[] | Int>;
  dias_not_in?: Maybe<Int[] | Int>;
  dias_lt?: Maybe<Int>;
  dias_lte?: Maybe<Int>;
  dias_gt?: Maybe<Int>;
  dias_gte?: Maybe<Int>;
  pago?: Maybe<Int>;
  pago_not?: Maybe<Int>;
  pago_in?: Maybe<Int[] | Int>;
  pago_not_in?: Maybe<Int[] | Int>;
  pago_lt?: Maybe<Int>;
  pago_lte?: Maybe<Int>;
  pago_gt?: Maybe<Int>;
  pago_gte?: Maybe<Int>;
  available?: Maybe<Boolean>;
  available_not?: Maybe<Boolean>;
  AND?: Maybe<ColaboratorWhereInput[] | ColaboratorWhereInput>;
}

export type ColaboratorWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  nomina?: Maybe<String>;
}>;

export type MovieWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export type OrdenDulceriaWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface OrdenDulceriaWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  amount?: Maybe<Int>;
  amount_not?: Maybe<Int>;
  amount_in?: Maybe<Int[] | Int>;
  amount_not_in?: Maybe<Int[] | Int>;
  amount_lt?: Maybe<Int>;
  amount_lte?: Maybe<Int>;
  amount_gt?: Maybe<Int>;
  amount_gte?: Maybe<Int>;
  Cine?: Maybe<CineWhereInput>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<OrdenDulceriaWhereInput[] | OrdenDulceriaWhereInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  points?: Maybe<Int>;
  points_not?: Maybe<Int>;
  points_in?: Maybe<Int[] | Int>;
  points_not_in?: Maybe<Int[] | Int>;
  points_lt?: Maybe<Int>;
  points_lte?: Maybe<Int>;
  points_gt?: Maybe<Int>;
  points_gte?: Maybe<Int>;
  cardStatus?: Maybe<Boolean>;
  cardStatus_not?: Maybe<Boolean>;
  available?: Maybe<Boolean>;
  available_not?: Maybe<Boolean>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export type PagoWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PagoWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  nomina?: Maybe<String>;
  nomina_not?: Maybe<String>;
  nomina_in?: Maybe<String[] | String>;
  nomina_not_in?: Maybe<String[] | String>;
  nomina_lt?: Maybe<String>;
  nomina_lte?: Maybe<String>;
  nomina_gt?: Maybe<String>;
  nomina_gte?: Maybe<String>;
  nomina_contains?: Maybe<String>;
  nomina_not_contains?: Maybe<String>;
  nomina_starts_with?: Maybe<String>;
  nomina_not_starts_with?: Maybe<String>;
  nomina_ends_with?: Maybe<String>;
  nomina_not_ends_with?: Maybe<String>;
  pago?: Maybe<Int>;
  pago_not?: Maybe<Int>;
  pago_in?: Maybe<Int[] | Int>;
  pago_not_in?: Maybe<Int[] | Int>;
  pago_lt?: Maybe<Int>;
  pago_lte?: Maybe<Int>;
  pago_gt?: Maybe<Int>;
  pago_gte?: Maybe<Int>;
  AND?: Maybe<PagoWhereInput[] | PagoWhereInput>;
}

export type RoomWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  number?: Maybe<Int>;
}>;

export type SeatWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface SeatWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  Room?: Maybe<RoomWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  available?: Maybe<Boolean>;
  available_not?: Maybe<Boolean>;
  AND?: Maybe<SeatWhereInput[] | SeatWhereInput>;
}

export type TicketWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TicketWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  seats_some?: Maybe<SeatWhereInput>;
  movie?: Maybe<MovieWhereInput>;
  cine?: Maybe<CineWhereInput>;
  user?: Maybe<UserWhereInput>;
  price?: Maybe<Int>;
  price_not?: Maybe<Int>;
  price_in?: Maybe<Int[] | Int>;
  price_not_in?: Maybe<Int[] | Int>;
  price_lt?: Maybe<Int>;
  price_lte?: Maybe<Int>;
  price_gt?: Maybe<Int>;
  price_gte?: Maybe<Int>;
  pagoPuntos?: Maybe<Boolean>;
  pagoPuntos_not?: Maybe<Boolean>;
  AND?: Maybe<TicketWhereInput[] | TicketWhereInput>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface CineCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  Colaborator?: Maybe<ColaboratorCreateOneWithoutCineInput>;
  room?: Maybe<RoomCreateManyInput>;
  ingresosDulceria?: Maybe<Int>;
  ingresosTickets?: Maybe<Int>;
  available?: Maybe<Boolean>;
}

export interface ColaboratorCreateOneWithoutCineInput {
  create?: Maybe<ColaboratorCreateWithoutCineInput>;
  connect?: Maybe<ColaboratorWhereUniqueInput>;
}

export interface ColaboratorCreateWithoutCineInput {
  id?: Maybe<ID_Input>;
  name: String;
  nomina: String;
  password: String;
  Area: String;
  dias?: Maybe<Int>;
  pago?: Maybe<Int>;
  available?: Maybe<Boolean>;
}

export interface RoomCreateManyInput {
  create?: Maybe<RoomCreateInput[] | RoomCreateInput>;
  connect?: Maybe<RoomWhereUniqueInput[] | RoomWhereUniqueInput>;
}

export interface RoomCreateInput {
  id?: Maybe<ID_Input>;
  number: Int;
  Movie?: Maybe<MovieCreateOneInput>;
  available?: Maybe<Boolean>;
}

export interface MovieCreateOneInput {
  create?: Maybe<MovieCreateInput>;
  connect?: Maybe<MovieWhereUniqueInput>;
}

export interface MovieCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  time: Int;
  rates: String;
  director: String;
  available?: Maybe<Boolean>;
}

export interface CineUpdateInput {
  name?: Maybe<String>;
  Colaborator?: Maybe<ColaboratorUpdateOneWithoutCineInput>;
  room?: Maybe<RoomUpdateManyInput>;
  ingresosDulceria?: Maybe<Int>;
  ingresosTickets?: Maybe<Int>;
  available?: Maybe<Boolean>;
}

export interface ColaboratorUpdateOneWithoutCineInput {
  create?: Maybe<ColaboratorCreateWithoutCineInput>;
  update?: Maybe<ColaboratorUpdateWithoutCineDataInput>;
  upsert?: Maybe<ColaboratorUpsertWithoutCineInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ColaboratorWhereUniqueInput>;
}

export interface ColaboratorUpdateWithoutCineDataInput {
  name?: Maybe<String>;
  nomina?: Maybe<String>;
  password?: Maybe<String>;
  Area?: Maybe<String>;
  dias?: Maybe<Int>;
  pago?: Maybe<Int>;
  available?: Maybe<Boolean>;
}

export interface ColaboratorUpsertWithoutCineInput {
  update: ColaboratorUpdateWithoutCineDataInput;
  create: ColaboratorCreateWithoutCineInput;
}

export interface RoomUpdateManyInput {
  create?: Maybe<RoomCreateInput[] | RoomCreateInput>;
  update?: Maybe<
    | RoomUpdateWithWhereUniqueNestedInput[]
    | RoomUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | RoomUpsertWithWhereUniqueNestedInput[]
    | RoomUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<RoomWhereUniqueInput[] | RoomWhereUniqueInput>;
  connect?: Maybe<RoomWhereUniqueInput[] | RoomWhereUniqueInput>;
  set?: Maybe<RoomWhereUniqueInput[] | RoomWhereUniqueInput>;
  disconnect?: Maybe<RoomWhereUniqueInput[] | RoomWhereUniqueInput>;
  deleteMany?: Maybe<RoomScalarWhereInput[] | RoomScalarWhereInput>;
  updateMany?: Maybe<
    RoomUpdateManyWithWhereNestedInput[] | RoomUpdateManyWithWhereNestedInput
  >;
}

export interface RoomUpdateWithWhereUniqueNestedInput {
  where: RoomWhereUniqueInput;
  data: RoomUpdateDataInput;
}

export interface RoomUpdateDataInput {
  number?: Maybe<Int>;
  Movie?: Maybe<MovieUpdateOneInput>;
  available?: Maybe<Boolean>;
}

export interface MovieUpdateOneInput {
  create?: Maybe<MovieCreateInput>;
  update?: Maybe<MovieUpdateDataInput>;
  upsert?: Maybe<MovieUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<MovieWhereUniqueInput>;
}

export interface MovieUpdateDataInput {
  name?: Maybe<String>;
  time?: Maybe<Int>;
  rates?: Maybe<String>;
  director?: Maybe<String>;
  available?: Maybe<Boolean>;
}

export interface MovieUpsertNestedInput {
  update: MovieUpdateDataInput;
  create: MovieCreateInput;
}

export interface RoomUpsertWithWhereUniqueNestedInput {
  where: RoomWhereUniqueInput;
  update: RoomUpdateDataInput;
  create: RoomCreateInput;
}

export interface RoomScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  number?: Maybe<Int>;
  number_not?: Maybe<Int>;
  number_in?: Maybe<Int[] | Int>;
  number_not_in?: Maybe<Int[] | Int>;
  number_lt?: Maybe<Int>;
  number_lte?: Maybe<Int>;
  number_gt?: Maybe<Int>;
  number_gte?: Maybe<Int>;
  available?: Maybe<Boolean>;
  available_not?: Maybe<Boolean>;
  AND?: Maybe<RoomScalarWhereInput[] | RoomScalarWhereInput>;
  OR?: Maybe<RoomScalarWhereInput[] | RoomScalarWhereInput>;
  NOT?: Maybe<RoomScalarWhereInput[] | RoomScalarWhereInput>;
}

export interface RoomUpdateManyWithWhereNestedInput {
  where: RoomScalarWhereInput;
  data: RoomUpdateManyDataInput;
}

export interface RoomUpdateManyDataInput {
  number?: Maybe<Int>;
  available?: Maybe<Boolean>;
}

export interface CineUpdateManyMutationInput {
  name?: Maybe<String>;
  ingresosDulceria?: Maybe<Int>;
  ingresosTickets?: Maybe<Int>;
  available?: Maybe<Boolean>;
}

export interface ColaboratorCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  nomina: String;
  password: String;
  Cine: CineCreateOneWithoutColaboratorInput;
  Area: String;
  dias?: Maybe<Int>;
  pago?: Maybe<Int>;
  available?: Maybe<Boolean>;
}

export interface CineCreateOneWithoutColaboratorInput {
  create?: Maybe<CineCreateWithoutColaboratorInput>;
  connect?: Maybe<CineWhereUniqueInput>;
}

export interface CineCreateWithoutColaboratorInput {
  id?: Maybe<ID_Input>;
  name: String;
  room?: Maybe<RoomCreateManyInput>;
  ingresosDulceria?: Maybe<Int>;
  ingresosTickets?: Maybe<Int>;
  available?: Maybe<Boolean>;
}

export interface ColaboratorUpdateInput {
  name?: Maybe<String>;
  nomina?: Maybe<String>;
  password?: Maybe<String>;
  Cine?: Maybe<CineUpdateOneRequiredWithoutColaboratorInput>;
  Area?: Maybe<String>;
  dias?: Maybe<Int>;
  pago?: Maybe<Int>;
  available?: Maybe<Boolean>;
}

export interface CineUpdateOneRequiredWithoutColaboratorInput {
  create?: Maybe<CineCreateWithoutColaboratorInput>;
  update?: Maybe<CineUpdateWithoutColaboratorDataInput>;
  upsert?: Maybe<CineUpsertWithoutColaboratorInput>;
  connect?: Maybe<CineWhereUniqueInput>;
}

export interface CineUpdateWithoutColaboratorDataInput {
  name?: Maybe<String>;
  room?: Maybe<RoomUpdateManyInput>;
  ingresosDulceria?: Maybe<Int>;
  ingresosTickets?: Maybe<Int>;
  available?: Maybe<Boolean>;
}

export interface CineUpsertWithoutColaboratorInput {
  update: CineUpdateWithoutColaboratorDataInput;
  create: CineCreateWithoutColaboratorInput;
}

export interface ColaboratorUpdateManyMutationInput {
  name?: Maybe<String>;
  nomina?: Maybe<String>;
  password?: Maybe<String>;
  Area?: Maybe<String>;
  dias?: Maybe<Int>;
  pago?: Maybe<Int>;
  available?: Maybe<Boolean>;
}

export interface MovieUpdateInput {
  name?: Maybe<String>;
  time?: Maybe<Int>;
  rates?: Maybe<String>;
  director?: Maybe<String>;
  available?: Maybe<Boolean>;
}

export interface MovieUpdateManyMutationInput {
  name?: Maybe<String>;
  time?: Maybe<Int>;
  rates?: Maybe<String>;
  director?: Maybe<String>;
  available?: Maybe<Boolean>;
}

export interface OrdenDulceriaCreateInput {
  id?: Maybe<ID_Input>;
  amount: Int;
  items?: Maybe<OrdenDulceriaCreateitemsInput>;
  Cine: CineCreateOneInput;
  user?: Maybe<UserCreateOneInput>;
}

export interface OrdenDulceriaCreateitemsInput {
  set?: Maybe<String[] | String>;
}

export interface CineCreateOneInput {
  create?: Maybe<CineCreateInput>;
  connect?: Maybe<CineWhereUniqueInput>;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  email: String;
  password?: Maybe<String>;
  name: String;
  points?: Maybe<Int>;
  cardStatus?: Maybe<Boolean>;
  available?: Maybe<Boolean>;
}

export interface OrdenDulceriaUpdateInput {
  amount?: Maybe<Int>;
  items?: Maybe<OrdenDulceriaUpdateitemsInput>;
  Cine?: Maybe<CineUpdateOneRequiredInput>;
  user?: Maybe<UserUpdateOneInput>;
}

export interface OrdenDulceriaUpdateitemsInput {
  set?: Maybe<String[] | String>;
}

export interface CineUpdateOneRequiredInput {
  create?: Maybe<CineCreateInput>;
  update?: Maybe<CineUpdateDataInput>;
  upsert?: Maybe<CineUpsertNestedInput>;
  connect?: Maybe<CineWhereUniqueInput>;
}

export interface CineUpdateDataInput {
  name?: Maybe<String>;
  Colaborator?: Maybe<ColaboratorUpdateOneWithoutCineInput>;
  room?: Maybe<RoomUpdateManyInput>;
  ingresosDulceria?: Maybe<Int>;
  ingresosTickets?: Maybe<Int>;
  available?: Maybe<Boolean>;
}

export interface CineUpsertNestedInput {
  update: CineUpdateDataInput;
  create: CineCreateInput;
}

export interface UserUpdateOneInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  name?: Maybe<String>;
  points?: Maybe<Int>;
  cardStatus?: Maybe<Boolean>;
  available?: Maybe<Boolean>;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface OrdenDulceriaUpdateManyMutationInput {
  amount?: Maybe<Int>;
  items?: Maybe<OrdenDulceriaUpdateitemsInput>;
}

export interface PagoCreateInput {
  id?: Maybe<ID_Input>;
  nomina: String;
  pago: Int;
}

export interface PagoUpdateInput {
  nomina?: Maybe<String>;
  pago?: Maybe<Int>;
}

export interface PagoUpdateManyMutationInput {
  nomina?: Maybe<String>;
  pago?: Maybe<Int>;
}

export interface RoomUpdateInput {
  number?: Maybe<Int>;
  Movie?: Maybe<MovieUpdateOneInput>;
  available?: Maybe<Boolean>;
}

export interface RoomUpdateManyMutationInput {
  number?: Maybe<Int>;
  available?: Maybe<Boolean>;
}

export interface SeatCreateInput {
  id?: Maybe<ID_Input>;
  Room: RoomCreateOneInput;
  name: String;
  available?: Maybe<Boolean>;
}

export interface RoomCreateOneInput {
  create?: Maybe<RoomCreateInput>;
  connect?: Maybe<RoomWhereUniqueInput>;
}

export interface SeatUpdateInput {
  Room?: Maybe<RoomUpdateOneRequiredInput>;
  name?: Maybe<String>;
  available?: Maybe<Boolean>;
}

export interface RoomUpdateOneRequiredInput {
  create?: Maybe<RoomCreateInput>;
  update?: Maybe<RoomUpdateDataInput>;
  upsert?: Maybe<RoomUpsertNestedInput>;
  connect?: Maybe<RoomWhereUniqueInput>;
}

export interface RoomUpsertNestedInput {
  update: RoomUpdateDataInput;
  create: RoomCreateInput;
}

export interface SeatUpdateManyMutationInput {
  name?: Maybe<String>;
  available?: Maybe<Boolean>;
}

export interface TicketCreateInput {
  id?: Maybe<ID_Input>;
  seats?: Maybe<SeatCreateManyInput>;
  movie: MovieCreateOneInput;
  cine: CineCreateOneInput;
  user?: Maybe<UserCreateOneInput>;
  price: Int;
  pagoPuntos?: Maybe<Boolean>;
}

export interface SeatCreateManyInput {
  create?: Maybe<SeatCreateInput[] | SeatCreateInput>;
  connect?: Maybe<SeatWhereUniqueInput[] | SeatWhereUniqueInput>;
}

export interface TicketUpdateInput {
  seats?: Maybe<SeatUpdateManyInput>;
  movie?: Maybe<MovieUpdateOneRequiredInput>;
  cine?: Maybe<CineUpdateOneRequiredInput>;
  user?: Maybe<UserUpdateOneInput>;
  price?: Maybe<Int>;
  pagoPuntos?: Maybe<Boolean>;
}

export interface SeatUpdateManyInput {
  create?: Maybe<SeatCreateInput[] | SeatCreateInput>;
  update?: Maybe<
    | SeatUpdateWithWhereUniqueNestedInput[]
    | SeatUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | SeatUpsertWithWhereUniqueNestedInput[]
    | SeatUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<SeatWhereUniqueInput[] | SeatWhereUniqueInput>;
  connect?: Maybe<SeatWhereUniqueInput[] | SeatWhereUniqueInput>;
  set?: Maybe<SeatWhereUniqueInput[] | SeatWhereUniqueInput>;
  disconnect?: Maybe<SeatWhereUniqueInput[] | SeatWhereUniqueInput>;
  deleteMany?: Maybe<SeatScalarWhereInput[] | SeatScalarWhereInput>;
  updateMany?: Maybe<
    SeatUpdateManyWithWhereNestedInput[] | SeatUpdateManyWithWhereNestedInput
  >;
}

export interface SeatUpdateWithWhereUniqueNestedInput {
  where: SeatWhereUniqueInput;
  data: SeatUpdateDataInput;
}

export interface SeatUpdateDataInput {
  Room?: Maybe<RoomUpdateOneRequiredInput>;
  name?: Maybe<String>;
  available?: Maybe<Boolean>;
}

export interface SeatUpsertWithWhereUniqueNestedInput {
  where: SeatWhereUniqueInput;
  update: SeatUpdateDataInput;
  create: SeatCreateInput;
}

export interface SeatScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  available?: Maybe<Boolean>;
  available_not?: Maybe<Boolean>;
  AND?: Maybe<SeatScalarWhereInput[] | SeatScalarWhereInput>;
  OR?: Maybe<SeatScalarWhereInput[] | SeatScalarWhereInput>;
  NOT?: Maybe<SeatScalarWhereInput[] | SeatScalarWhereInput>;
}

export interface SeatUpdateManyWithWhereNestedInput {
  where: SeatScalarWhereInput;
  data: SeatUpdateManyDataInput;
}

export interface SeatUpdateManyDataInput {
  name?: Maybe<String>;
  available?: Maybe<Boolean>;
}

export interface MovieUpdateOneRequiredInput {
  create?: Maybe<MovieCreateInput>;
  update?: Maybe<MovieUpdateDataInput>;
  upsert?: Maybe<MovieUpsertNestedInput>;
  connect?: Maybe<MovieWhereUniqueInput>;
}

export interface TicketUpdateManyMutationInput {
  price?: Maybe<Int>;
  pagoPuntos?: Maybe<Boolean>;
}

export interface UserUpdateInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  name?: Maybe<String>;
  points?: Maybe<Int>;
  cardStatus?: Maybe<Boolean>;
  available?: Maybe<Boolean>;
}

export interface UserUpdateManyMutationInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  name?: Maybe<String>;
  points?: Maybe<Int>;
  cardStatus?: Maybe<Boolean>;
  available?: Maybe<Boolean>;
}

export interface CineSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CineWhereInput>;
  AND?: Maybe<CineSubscriptionWhereInput[] | CineSubscriptionWhereInput>;
}

export interface ColaboratorSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ColaboratorWhereInput>;
  AND?: Maybe<
    ColaboratorSubscriptionWhereInput[] | ColaboratorSubscriptionWhereInput
  >;
}

export interface MovieSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MovieWhereInput>;
  AND?: Maybe<MovieSubscriptionWhereInput[] | MovieSubscriptionWhereInput>;
}

export interface OrdenDulceriaSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OrdenDulceriaWhereInput>;
  AND?: Maybe<
    OrdenDulceriaSubscriptionWhereInput[] | OrdenDulceriaSubscriptionWhereInput
  >;
}

export interface PagoSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PagoWhereInput>;
  AND?: Maybe<PagoSubscriptionWhereInput[] | PagoSubscriptionWhereInput>;
}

export interface RoomSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RoomWhereInput>;
  AND?: Maybe<RoomSubscriptionWhereInput[] | RoomSubscriptionWhereInput>;
}

export interface SeatSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SeatWhereInput>;
  AND?: Maybe<SeatSubscriptionWhereInput[] | SeatSubscriptionWhereInput>;
}

export interface TicketSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TicketWhereInput>;
  AND?: Maybe<TicketSubscriptionWhereInput[] | TicketSubscriptionWhereInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Cine {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  ingresosDulceria?: Int;
  ingresosTickets?: Int;
  available?: Boolean;
}

export interface CinePromise extends Promise<Cine>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  Colaborator: <T = ColaboratorPromise>() => T;
  room: <T = FragmentableArray<Room>>(args?: {
    where?: RoomWhereInput;
    orderBy?: RoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  ingresosDulceria: () => Promise<Int>;
  ingresosTickets: () => Promise<Int>;
  available: () => Promise<Boolean>;
}

export interface CineSubscription
  extends Promise<AsyncIterator<Cine>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  Colaborator: <T = ColaboratorSubscription>() => T;
  room: <T = Promise<AsyncIterator<RoomSubscription>>>(args?: {
    where?: RoomWhereInput;
    orderBy?: RoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  ingresosDulceria: () => Promise<AsyncIterator<Int>>;
  ingresosTickets: () => Promise<AsyncIterator<Int>>;
  available: () => Promise<AsyncIterator<Boolean>>;
}

export interface CineNullablePromise
  extends Promise<Cine | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  Colaborator: <T = ColaboratorPromise>() => T;
  room: <T = FragmentableArray<Room>>(args?: {
    where?: RoomWhereInput;
    orderBy?: RoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  ingresosDulceria: () => Promise<Int>;
  ingresosTickets: () => Promise<Int>;
  available: () => Promise<Boolean>;
}

export interface Colaborator {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  nomina: String;
  password: String;
  Area: String;
  dias?: Int;
  pago?: Int;
  available: Boolean;
}

export interface ColaboratorPromise extends Promise<Colaborator>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  nomina: () => Promise<String>;
  password: () => Promise<String>;
  Cine: <T = CinePromise>() => T;
  Area: () => Promise<String>;
  dias: () => Promise<Int>;
  pago: () => Promise<Int>;
  available: () => Promise<Boolean>;
}

export interface ColaboratorSubscription
  extends Promise<AsyncIterator<Colaborator>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  nomina: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  Cine: <T = CineSubscription>() => T;
  Area: () => Promise<AsyncIterator<String>>;
  dias: () => Promise<AsyncIterator<Int>>;
  pago: () => Promise<AsyncIterator<Int>>;
  available: () => Promise<AsyncIterator<Boolean>>;
}

export interface ColaboratorNullablePromise
  extends Promise<Colaborator | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  nomina: () => Promise<String>;
  password: () => Promise<String>;
  Cine: <T = CinePromise>() => T;
  Area: () => Promise<String>;
  dias: () => Promise<Int>;
  pago: () => Promise<Int>;
  available: () => Promise<Boolean>;
}

export interface Room {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  number: Int;
  available: Boolean;
}

export interface RoomPromise extends Promise<Room>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  number: () => Promise<Int>;
  Movie: <T = MoviePromise>() => T;
  available: () => Promise<Boolean>;
}

export interface RoomSubscription
  extends Promise<AsyncIterator<Room>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  number: () => Promise<AsyncIterator<Int>>;
  Movie: <T = MovieSubscription>() => T;
  available: () => Promise<AsyncIterator<Boolean>>;
}

export interface RoomNullablePromise
  extends Promise<Room | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  number: () => Promise<Int>;
  Movie: <T = MoviePromise>() => T;
  available: () => Promise<Boolean>;
}

export interface Movie {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  time: Int;
  rates: String;
  director: String;
  available?: Boolean;
}

export interface MoviePromise extends Promise<Movie>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  time: () => Promise<Int>;
  rates: () => Promise<String>;
  director: () => Promise<String>;
  available: () => Promise<Boolean>;
}

export interface MovieSubscription
  extends Promise<AsyncIterator<Movie>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  time: () => Promise<AsyncIterator<Int>>;
  rates: () => Promise<AsyncIterator<String>>;
  director: () => Promise<AsyncIterator<String>>;
  available: () => Promise<AsyncIterator<Boolean>>;
}

export interface MovieNullablePromise
  extends Promise<Movie | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  time: () => Promise<Int>;
  rates: () => Promise<String>;
  director: () => Promise<String>;
  available: () => Promise<Boolean>;
}

export interface CineConnection {
  pageInfo: PageInfo;
  edges: CineEdge[];
}

export interface CineConnectionPromise
  extends Promise<CineConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CineEdge>>() => T;
  aggregate: <T = AggregateCinePromise>() => T;
}

export interface CineConnectionSubscription
  extends Promise<AsyncIterator<CineConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CineEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCineSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface CineEdge {
  node: Cine;
  cursor: String;
}

export interface CineEdgePromise extends Promise<CineEdge>, Fragmentable {
  node: <T = CinePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CineEdgeSubscription
  extends Promise<AsyncIterator<CineEdge>>,
    Fragmentable {
  node: <T = CineSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCine {
  count: Int;
}

export interface AggregateCinePromise
  extends Promise<AggregateCine>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCineSubscription
  extends Promise<AsyncIterator<AggregateCine>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ColaboratorConnection {
  pageInfo: PageInfo;
  edges: ColaboratorEdge[];
}

export interface ColaboratorConnectionPromise
  extends Promise<ColaboratorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ColaboratorEdge>>() => T;
  aggregate: <T = AggregateColaboratorPromise>() => T;
}

export interface ColaboratorConnectionSubscription
  extends Promise<AsyncIterator<ColaboratorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ColaboratorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateColaboratorSubscription>() => T;
}

export interface ColaboratorEdge {
  node: Colaborator;
  cursor: String;
}

export interface ColaboratorEdgePromise
  extends Promise<ColaboratorEdge>,
    Fragmentable {
  node: <T = ColaboratorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ColaboratorEdgeSubscription
  extends Promise<AsyncIterator<ColaboratorEdge>>,
    Fragmentable {
  node: <T = ColaboratorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateColaborator {
  count: Int;
}

export interface AggregateColaboratorPromise
  extends Promise<AggregateColaborator>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateColaboratorSubscription
  extends Promise<AsyncIterator<AggregateColaborator>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MovieConnection {
  pageInfo: PageInfo;
  edges: MovieEdge[];
}

export interface MovieConnectionPromise
  extends Promise<MovieConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MovieEdge>>() => T;
  aggregate: <T = AggregateMoviePromise>() => T;
}

export interface MovieConnectionSubscription
  extends Promise<AsyncIterator<MovieConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MovieEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMovieSubscription>() => T;
}

export interface MovieEdge {
  node: Movie;
  cursor: String;
}

export interface MovieEdgePromise extends Promise<MovieEdge>, Fragmentable {
  node: <T = MoviePromise>() => T;
  cursor: () => Promise<String>;
}

export interface MovieEdgeSubscription
  extends Promise<AsyncIterator<MovieEdge>>,
    Fragmentable {
  node: <T = MovieSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMovie {
  count: Int;
}

export interface AggregateMoviePromise
  extends Promise<AggregateMovie>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMovieSubscription
  extends Promise<AsyncIterator<AggregateMovie>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OrdenDulceria {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  amount: Int;
  items: String[];
}

export interface OrdenDulceriaPromise
  extends Promise<OrdenDulceria>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  amount: () => Promise<Int>;
  items: () => Promise<String[]>;
  Cine: <T = CinePromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface OrdenDulceriaSubscription
  extends Promise<AsyncIterator<OrdenDulceria>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amount: () => Promise<AsyncIterator<Int>>;
  items: () => Promise<AsyncIterator<String[]>>;
  Cine: <T = CineSubscription>() => T;
  user: <T = UserSubscription>() => T;
}

export interface OrdenDulceriaNullablePromise
  extends Promise<OrdenDulceria | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  amount: () => Promise<Int>;
  items: () => Promise<String[]>;
  Cine: <T = CinePromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface User {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  email: String;
  password?: String;
  name: String;
  points?: Int;
  cardStatus: Boolean;
  available?: Boolean;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  name: () => Promise<String>;
  points: () => Promise<Int>;
  cardStatus: () => Promise<Boolean>;
  available: () => Promise<Boolean>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  points: () => Promise<AsyncIterator<Int>>;
  cardStatus: () => Promise<AsyncIterator<Boolean>>;
  available: () => Promise<AsyncIterator<Boolean>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  name: () => Promise<String>;
  points: () => Promise<Int>;
  cardStatus: () => Promise<Boolean>;
  available: () => Promise<Boolean>;
}

export interface OrdenDulceriaConnection {
  pageInfo: PageInfo;
  edges: OrdenDulceriaEdge[];
}

export interface OrdenDulceriaConnectionPromise
  extends Promise<OrdenDulceriaConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrdenDulceriaEdge>>() => T;
  aggregate: <T = AggregateOrdenDulceriaPromise>() => T;
}

export interface OrdenDulceriaConnectionSubscription
  extends Promise<AsyncIterator<OrdenDulceriaConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrdenDulceriaEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrdenDulceriaSubscription>() => T;
}

export interface OrdenDulceriaEdge {
  node: OrdenDulceria;
  cursor: String;
}

export interface OrdenDulceriaEdgePromise
  extends Promise<OrdenDulceriaEdge>,
    Fragmentable {
  node: <T = OrdenDulceriaPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrdenDulceriaEdgeSubscription
  extends Promise<AsyncIterator<OrdenDulceriaEdge>>,
    Fragmentable {
  node: <T = OrdenDulceriaSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOrdenDulceria {
  count: Int;
}

export interface AggregateOrdenDulceriaPromise
  extends Promise<AggregateOrdenDulceria>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrdenDulceriaSubscription
  extends Promise<AsyncIterator<AggregateOrdenDulceria>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Pago {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  nomina: String;
  pago: Int;
}

export interface PagoPromise extends Promise<Pago>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  nomina: () => Promise<String>;
  pago: () => Promise<Int>;
}

export interface PagoSubscription
  extends Promise<AsyncIterator<Pago>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  nomina: () => Promise<AsyncIterator<String>>;
  pago: () => Promise<AsyncIterator<Int>>;
}

export interface PagoNullablePromise
  extends Promise<Pago | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  nomina: () => Promise<String>;
  pago: () => Promise<Int>;
}

export interface PagoConnection {
  pageInfo: PageInfo;
  edges: PagoEdge[];
}

export interface PagoConnectionPromise
  extends Promise<PagoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PagoEdge>>() => T;
  aggregate: <T = AggregatePagoPromise>() => T;
}

export interface PagoConnectionSubscription
  extends Promise<AsyncIterator<PagoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PagoEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePagoSubscription>() => T;
}

export interface PagoEdge {
  node: Pago;
  cursor: String;
}

export interface PagoEdgePromise extends Promise<PagoEdge>, Fragmentable {
  node: <T = PagoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PagoEdgeSubscription
  extends Promise<AsyncIterator<PagoEdge>>,
    Fragmentable {
  node: <T = PagoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePago {
  count: Int;
}

export interface AggregatePagoPromise
  extends Promise<AggregatePago>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePagoSubscription
  extends Promise<AsyncIterator<AggregatePago>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RoomConnection {
  pageInfo: PageInfo;
  edges: RoomEdge[];
}

export interface RoomConnectionPromise
  extends Promise<RoomConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RoomEdge>>() => T;
  aggregate: <T = AggregateRoomPromise>() => T;
}

export interface RoomConnectionSubscription
  extends Promise<AsyncIterator<RoomConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RoomEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRoomSubscription>() => T;
}

export interface RoomEdge {
  node: Room;
  cursor: String;
}

export interface RoomEdgePromise extends Promise<RoomEdge>, Fragmentable {
  node: <T = RoomPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RoomEdgeSubscription
  extends Promise<AsyncIterator<RoomEdge>>,
    Fragmentable {
  node: <T = RoomSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRoom {
  count: Int;
}

export interface AggregateRoomPromise
  extends Promise<AggregateRoom>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRoomSubscription
  extends Promise<AsyncIterator<AggregateRoom>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Seat {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  available: Boolean;
}

export interface SeatPromise extends Promise<Seat>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  Room: <T = RoomPromise>() => T;
  name: () => Promise<String>;
  available: () => Promise<Boolean>;
}

export interface SeatSubscription
  extends Promise<AsyncIterator<Seat>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  Room: <T = RoomSubscription>() => T;
  name: () => Promise<AsyncIterator<String>>;
  available: () => Promise<AsyncIterator<Boolean>>;
}

export interface SeatNullablePromise
  extends Promise<Seat | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  Room: <T = RoomPromise>() => T;
  name: () => Promise<String>;
  available: () => Promise<Boolean>;
}

export interface SeatConnection {
  pageInfo: PageInfo;
  edges: SeatEdge[];
}

export interface SeatConnectionPromise
  extends Promise<SeatConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SeatEdge>>() => T;
  aggregate: <T = AggregateSeatPromise>() => T;
}

export interface SeatConnectionSubscription
  extends Promise<AsyncIterator<SeatConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SeatEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSeatSubscription>() => T;
}

export interface SeatEdge {
  node: Seat;
  cursor: String;
}

export interface SeatEdgePromise extends Promise<SeatEdge>, Fragmentable {
  node: <T = SeatPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SeatEdgeSubscription
  extends Promise<AsyncIterator<SeatEdge>>,
    Fragmentable {
  node: <T = SeatSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSeat {
  count: Int;
}

export interface AggregateSeatPromise
  extends Promise<AggregateSeat>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSeatSubscription
  extends Promise<AsyncIterator<AggregateSeat>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Ticket {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  price: Int;
  pagoPuntos?: Boolean;
}

export interface TicketPromise extends Promise<Ticket>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  seats: <T = FragmentableArray<Seat>>(args?: {
    where?: SeatWhereInput;
    orderBy?: SeatOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  movie: <T = MoviePromise>() => T;
  cine: <T = CinePromise>() => T;
  user: <T = UserPromise>() => T;
  price: () => Promise<Int>;
  pagoPuntos: () => Promise<Boolean>;
}

export interface TicketSubscription
  extends Promise<AsyncIterator<Ticket>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  seats: <T = Promise<AsyncIterator<SeatSubscription>>>(args?: {
    where?: SeatWhereInput;
    orderBy?: SeatOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  movie: <T = MovieSubscription>() => T;
  cine: <T = CineSubscription>() => T;
  user: <T = UserSubscription>() => T;
  price: () => Promise<AsyncIterator<Int>>;
  pagoPuntos: () => Promise<AsyncIterator<Boolean>>;
}

export interface TicketNullablePromise
  extends Promise<Ticket | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  seats: <T = FragmentableArray<Seat>>(args?: {
    where?: SeatWhereInput;
    orderBy?: SeatOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  movie: <T = MoviePromise>() => T;
  cine: <T = CinePromise>() => T;
  user: <T = UserPromise>() => T;
  price: () => Promise<Int>;
  pagoPuntos: () => Promise<Boolean>;
}

export interface TicketConnection {
  pageInfo: PageInfo;
  edges: TicketEdge[];
}

export interface TicketConnectionPromise
  extends Promise<TicketConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TicketEdge>>() => T;
  aggregate: <T = AggregateTicketPromise>() => T;
}

export interface TicketConnectionSubscription
  extends Promise<AsyncIterator<TicketConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TicketEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTicketSubscription>() => T;
}

export interface TicketEdge {
  node: Ticket;
  cursor: String;
}

export interface TicketEdgePromise extends Promise<TicketEdge>, Fragmentable {
  node: <T = TicketPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TicketEdgeSubscription
  extends Promise<AsyncIterator<TicketEdge>>,
    Fragmentable {
  node: <T = TicketSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTicket {
  count: Int;
}

export interface AggregateTicketPromise
  extends Promise<AggregateTicket>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTicketSubscription
  extends Promise<AsyncIterator<AggregateTicket>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface CineSubscriptionPayload {
  mutation: MutationType;
  node: Cine;
  updatedFields: String[];
  previousValues: CinePreviousValues;
}

export interface CineSubscriptionPayloadPromise
  extends Promise<CineSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CinePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CinePreviousValuesPromise>() => T;
}

export interface CineSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CineSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CineSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CinePreviousValuesSubscription>() => T;
}

export interface CinePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  ingresosDulceria?: Int;
  ingresosTickets?: Int;
  available?: Boolean;
}

export interface CinePreviousValuesPromise
  extends Promise<CinePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  ingresosDulceria: () => Promise<Int>;
  ingresosTickets: () => Promise<Int>;
  available: () => Promise<Boolean>;
}

export interface CinePreviousValuesSubscription
  extends Promise<AsyncIterator<CinePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  ingresosDulceria: () => Promise<AsyncIterator<Int>>;
  ingresosTickets: () => Promise<AsyncIterator<Int>>;
  available: () => Promise<AsyncIterator<Boolean>>;
}

export interface ColaboratorSubscriptionPayload {
  mutation: MutationType;
  node: Colaborator;
  updatedFields: String[];
  previousValues: ColaboratorPreviousValues;
}

export interface ColaboratorSubscriptionPayloadPromise
  extends Promise<ColaboratorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ColaboratorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ColaboratorPreviousValuesPromise>() => T;
}

export interface ColaboratorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ColaboratorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ColaboratorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ColaboratorPreviousValuesSubscription>() => T;
}

export interface ColaboratorPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  nomina: String;
  password: String;
  Area: String;
  dias?: Int;
  pago?: Int;
  available: Boolean;
}

export interface ColaboratorPreviousValuesPromise
  extends Promise<ColaboratorPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  nomina: () => Promise<String>;
  password: () => Promise<String>;
  Area: () => Promise<String>;
  dias: () => Promise<Int>;
  pago: () => Promise<Int>;
  available: () => Promise<Boolean>;
}

export interface ColaboratorPreviousValuesSubscription
  extends Promise<AsyncIterator<ColaboratorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  nomina: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  Area: () => Promise<AsyncIterator<String>>;
  dias: () => Promise<AsyncIterator<Int>>;
  pago: () => Promise<AsyncIterator<Int>>;
  available: () => Promise<AsyncIterator<Boolean>>;
}

export interface MovieSubscriptionPayload {
  mutation: MutationType;
  node: Movie;
  updatedFields: String[];
  previousValues: MoviePreviousValues;
}

export interface MovieSubscriptionPayloadPromise
  extends Promise<MovieSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MoviePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MoviePreviousValuesPromise>() => T;
}

export interface MovieSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MovieSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MovieSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MoviePreviousValuesSubscription>() => T;
}

export interface MoviePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  time: Int;
  rates: String;
  director: String;
  available?: Boolean;
}

export interface MoviePreviousValuesPromise
  extends Promise<MoviePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  time: () => Promise<Int>;
  rates: () => Promise<String>;
  director: () => Promise<String>;
  available: () => Promise<Boolean>;
}

export interface MoviePreviousValuesSubscription
  extends Promise<AsyncIterator<MoviePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  time: () => Promise<AsyncIterator<Int>>;
  rates: () => Promise<AsyncIterator<String>>;
  director: () => Promise<AsyncIterator<String>>;
  available: () => Promise<AsyncIterator<Boolean>>;
}

export interface OrdenDulceriaSubscriptionPayload {
  mutation: MutationType;
  node: OrdenDulceria;
  updatedFields: String[];
  previousValues: OrdenDulceriaPreviousValues;
}

export interface OrdenDulceriaSubscriptionPayloadPromise
  extends Promise<OrdenDulceriaSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrdenDulceriaPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrdenDulceriaPreviousValuesPromise>() => T;
}

export interface OrdenDulceriaSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrdenDulceriaSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrdenDulceriaSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrdenDulceriaPreviousValuesSubscription>() => T;
}

export interface OrdenDulceriaPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  amount: Int;
  items: String[];
}

export interface OrdenDulceriaPreviousValuesPromise
  extends Promise<OrdenDulceriaPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  amount: () => Promise<Int>;
  items: () => Promise<String[]>;
}

export interface OrdenDulceriaPreviousValuesSubscription
  extends Promise<AsyncIterator<OrdenDulceriaPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amount: () => Promise<AsyncIterator<Int>>;
  items: () => Promise<AsyncIterator<String[]>>;
}

export interface PagoSubscriptionPayload {
  mutation: MutationType;
  node: Pago;
  updatedFields: String[];
  previousValues: PagoPreviousValues;
}

export interface PagoSubscriptionPayloadPromise
  extends Promise<PagoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PagoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PagoPreviousValuesPromise>() => T;
}

export interface PagoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PagoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PagoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PagoPreviousValuesSubscription>() => T;
}

export interface PagoPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  nomina: String;
  pago: Int;
}

export interface PagoPreviousValuesPromise
  extends Promise<PagoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  nomina: () => Promise<String>;
  pago: () => Promise<Int>;
}

export interface PagoPreviousValuesSubscription
  extends Promise<AsyncIterator<PagoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  nomina: () => Promise<AsyncIterator<String>>;
  pago: () => Promise<AsyncIterator<Int>>;
}

export interface RoomSubscriptionPayload {
  mutation: MutationType;
  node: Room;
  updatedFields: String[];
  previousValues: RoomPreviousValues;
}

export interface RoomSubscriptionPayloadPromise
  extends Promise<RoomSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RoomPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RoomPreviousValuesPromise>() => T;
}

export interface RoomSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RoomSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RoomSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RoomPreviousValuesSubscription>() => T;
}

export interface RoomPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  number: Int;
  available: Boolean;
}

export interface RoomPreviousValuesPromise
  extends Promise<RoomPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  number: () => Promise<Int>;
  available: () => Promise<Boolean>;
}

export interface RoomPreviousValuesSubscription
  extends Promise<AsyncIterator<RoomPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  number: () => Promise<AsyncIterator<Int>>;
  available: () => Promise<AsyncIterator<Boolean>>;
}

export interface SeatSubscriptionPayload {
  mutation: MutationType;
  node: Seat;
  updatedFields: String[];
  previousValues: SeatPreviousValues;
}

export interface SeatSubscriptionPayloadPromise
  extends Promise<SeatSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SeatPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SeatPreviousValuesPromise>() => T;
}

export interface SeatSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SeatSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SeatSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SeatPreviousValuesSubscription>() => T;
}

export interface SeatPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  available: Boolean;
}

export interface SeatPreviousValuesPromise
  extends Promise<SeatPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  available: () => Promise<Boolean>;
}

export interface SeatPreviousValuesSubscription
  extends Promise<AsyncIterator<SeatPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  available: () => Promise<AsyncIterator<Boolean>>;
}

export interface TicketSubscriptionPayload {
  mutation: MutationType;
  node: Ticket;
  updatedFields: String[];
  previousValues: TicketPreviousValues;
}

export interface TicketSubscriptionPayloadPromise
  extends Promise<TicketSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TicketPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TicketPreviousValuesPromise>() => T;
}

export interface TicketSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TicketSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TicketSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TicketPreviousValuesSubscription>() => T;
}

export interface TicketPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  price: Int;
  pagoPuntos?: Boolean;
}

export interface TicketPreviousValuesPromise
  extends Promise<TicketPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  price: () => Promise<Int>;
  pagoPuntos: () => Promise<Boolean>;
}

export interface TicketPreviousValuesSubscription
  extends Promise<AsyncIterator<TicketPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  price: () => Promise<AsyncIterator<Int>>;
  pagoPuntos: () => Promise<AsyncIterator<Boolean>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  email: String;
  password?: String;
  name: String;
  points?: Int;
  cardStatus: Boolean;
  available?: Boolean;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  name: () => Promise<String>;
  points: () => Promise<Int>;
  cardStatus: () => Promise<Boolean>;
  available: () => Promise<Boolean>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  points: () => Promise<AsyncIterator<Int>>;
  cardStatus: () => Promise<AsyncIterator<Boolean>>;
  available: () => Promise<AsyncIterator<Boolean>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Movie",
    embedded: false
  },
  {
    name: "Room",
    embedded: false
  },
  {
    name: "Ticket",
    embedded: false
  },
  {
    name: "Cine",
    embedded: false
  },
  {
    name: "Colaborator",
    embedded: false
  },
  {
    name: "Pago",
    embedded: false
  },
  {
    name: "OrdenDulceria",
    embedded: false
  },
  {
    name: "Seat",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env["URL_BASE"]}/pemiliano/${process.env["ENVIROMENT"]}`,
  secret: `${process.env["PRISMA_SECRET"]}`
});
export const prisma = new Prisma();
