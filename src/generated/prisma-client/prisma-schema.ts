// Code generated by Prisma (prisma@1.34.12). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateCine {
  count: Int!
}

type AggregateColaborator {
  count: Int!
}

type AggregateMovie {
  count: Int!
}

type AggregateOrdenDulceria {
  count: Int!
}

type AggregatePago {
  count: Int!
}

type AggregateRoom {
  count: Int!
}

type AggregateSeat {
  count: Int!
}

type AggregateTicket {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Cine {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  Colaborator: Colaborator
  room(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Room!]
  ingresosDulceria: Int
  ingresosTickets: Int
  available: Boolean
}

type CineConnection {
  pageInfo: PageInfo!
  edges: [CineEdge]!
  aggregate: AggregateCine!
}

input CineCreateInput {
  id: ID
  name: String!
  Colaborator: ColaboratorCreateOneWithoutCineInput
  room: RoomCreateManyInput
  ingresosDulceria: Int
  ingresosTickets: Int
  available: Boolean
}

input CineCreateOneInput {
  create: CineCreateInput
  connect: CineWhereUniqueInput
}

input CineCreateOneWithoutColaboratorInput {
  create: CineCreateWithoutColaboratorInput
  connect: CineWhereUniqueInput
}

input CineCreateWithoutColaboratorInput {
  id: ID
  name: String!
  room: RoomCreateManyInput
  ingresosDulceria: Int
  ingresosTickets: Int
  available: Boolean
}

type CineEdge {
  node: Cine!
  cursor: String!
}

enum CineOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  name_ASC
  name_DESC
  ingresosDulceria_ASC
  ingresosDulceria_DESC
  ingresosTickets_ASC
  ingresosTickets_DESC
  available_ASC
  available_DESC
}

type CinePreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  ingresosDulceria: Int
  ingresosTickets: Int
  available: Boolean
}

type CineSubscriptionPayload {
  mutation: MutationType!
  node: Cine
  updatedFields: [String!]
  previousValues: CinePreviousValues
}

input CineSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CineWhereInput
  AND: [CineSubscriptionWhereInput!]
}

input CineUpdateDataInput {
  name: String
  Colaborator: ColaboratorUpdateOneWithoutCineInput
  room: RoomUpdateManyInput
  ingresosDulceria: Int
  ingresosTickets: Int
  available: Boolean
}

input CineUpdateInput {
  name: String
  Colaborator: ColaboratorUpdateOneWithoutCineInput
  room: RoomUpdateManyInput
  ingresosDulceria: Int
  ingresosTickets: Int
  available: Boolean
}

input CineUpdateManyMutationInput {
  name: String
  ingresosDulceria: Int
  ingresosTickets: Int
  available: Boolean
}

input CineUpdateOneRequiredInput {
  create: CineCreateInput
  update: CineUpdateDataInput
  upsert: CineUpsertNestedInput
  connect: CineWhereUniqueInput
}

input CineUpdateOneRequiredWithoutColaboratorInput {
  create: CineCreateWithoutColaboratorInput
  update: CineUpdateWithoutColaboratorDataInput
  upsert: CineUpsertWithoutColaboratorInput
  connect: CineWhereUniqueInput
}

input CineUpdateWithoutColaboratorDataInput {
  name: String
  room: RoomUpdateManyInput
  ingresosDulceria: Int
  ingresosTickets: Int
  available: Boolean
}

input CineUpsertNestedInput {
  update: CineUpdateDataInput!
  create: CineCreateInput!
}

input CineUpsertWithoutColaboratorInput {
  update: CineUpdateWithoutColaboratorDataInput!
  create: CineCreateWithoutColaboratorInput!
}

input CineWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  Colaborator: ColaboratorWhereInput
  room_some: RoomWhereInput
  ingresosDulceria: Int
  ingresosDulceria_not: Int
  ingresosDulceria_in: [Int!]
  ingresosDulceria_not_in: [Int!]
  ingresosDulceria_lt: Int
  ingresosDulceria_lte: Int
  ingresosDulceria_gt: Int
  ingresosDulceria_gte: Int
  ingresosTickets: Int
  ingresosTickets_not: Int
  ingresosTickets_in: [Int!]
  ingresosTickets_not_in: [Int!]
  ingresosTickets_lt: Int
  ingresosTickets_lte: Int
  ingresosTickets_gt: Int
  ingresosTickets_gte: Int
  available: Boolean
  available_not: Boolean
  AND: [CineWhereInput!]
}

input CineWhereUniqueInput {
  id: ID
}

type Colaborator {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  nomina: String!
  password: String!
  Cine: Cine!
  Area: String!
  dias: Int
  pago: Int
  available: Boolean!
}

type ColaboratorConnection {
  pageInfo: PageInfo!
  edges: [ColaboratorEdge]!
  aggregate: AggregateColaborator!
}

input ColaboratorCreateInput {
  id: ID
  name: String!
  nomina: String!
  password: String!
  Cine: CineCreateOneWithoutColaboratorInput!
  Area: String!
  dias: Int
  pago: Int
  available: Boolean
}

input ColaboratorCreateOneWithoutCineInput {
  create: ColaboratorCreateWithoutCineInput
  connect: ColaboratorWhereUniqueInput
}

input ColaboratorCreateWithoutCineInput {
  id: ID
  name: String!
  nomina: String!
  password: String!
  Area: String!
  dias: Int
  pago: Int
  available: Boolean
}

type ColaboratorEdge {
  node: Colaborator!
  cursor: String!
}

enum ColaboratorOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  name_ASC
  name_DESC
  nomina_ASC
  nomina_DESC
  password_ASC
  password_DESC
  Area_ASC
  Area_DESC
  dias_ASC
  dias_DESC
  pago_ASC
  pago_DESC
  available_ASC
  available_DESC
}

type ColaboratorPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  nomina: String!
  password: String!
  Area: String!
  dias: Int
  pago: Int
  available: Boolean!
}

type ColaboratorSubscriptionPayload {
  mutation: MutationType!
  node: Colaborator
  updatedFields: [String!]
  previousValues: ColaboratorPreviousValues
}

input ColaboratorSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ColaboratorWhereInput
  AND: [ColaboratorSubscriptionWhereInput!]
}

input ColaboratorUpdateInput {
  name: String
  nomina: String
  password: String
  Cine: CineUpdateOneRequiredWithoutColaboratorInput
  Area: String
  dias: Int
  pago: Int
  available: Boolean
}

input ColaboratorUpdateManyMutationInput {
  name: String
  nomina: String
  password: String
  Area: String
  dias: Int
  pago: Int
  available: Boolean
}

input ColaboratorUpdateOneWithoutCineInput {
  create: ColaboratorCreateWithoutCineInput
  update: ColaboratorUpdateWithoutCineDataInput
  upsert: ColaboratorUpsertWithoutCineInput
  delete: Boolean
  disconnect: Boolean
  connect: ColaboratorWhereUniqueInput
}

input ColaboratorUpdateWithoutCineDataInput {
  name: String
  nomina: String
  password: String
  Area: String
  dias: Int
  pago: Int
  available: Boolean
}

input ColaboratorUpsertWithoutCineInput {
  update: ColaboratorUpdateWithoutCineDataInput!
  create: ColaboratorCreateWithoutCineInput!
}

input ColaboratorWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  nomina: String
  nomina_not: String
  nomina_in: [String!]
  nomina_not_in: [String!]
  nomina_lt: String
  nomina_lte: String
  nomina_gt: String
  nomina_gte: String
  nomina_contains: String
  nomina_not_contains: String
  nomina_starts_with: String
  nomina_not_starts_with: String
  nomina_ends_with: String
  nomina_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  Cine: CineWhereInput
  Area: String
  Area_not: String
  Area_in: [String!]
  Area_not_in: [String!]
  Area_lt: String
  Area_lte: String
  Area_gt: String
  Area_gte: String
  Area_contains: String
  Area_not_contains: String
  Area_starts_with: String
  Area_not_starts_with: String
  Area_ends_with: String
  Area_not_ends_with: String
  dias: Int
  dias_not: Int
  dias_in: [Int!]
  dias_not_in: [Int!]
  dias_lt: Int
  dias_lte: Int
  dias_gt: Int
  dias_gte: Int
  pago: Int
  pago_not: Int
  pago_in: [Int!]
  pago_not_in: [Int!]
  pago_lt: Int
  pago_lte: Int
  pago_gt: Int
  pago_gte: Int
  available: Boolean
  available_not: Boolean
  AND: [ColaboratorWhereInput!]
}

input ColaboratorWhereUniqueInput {
  id: ID
  nomina: String
}

scalar DateTime

scalar Long

type Movie {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  time: Int!
  rates: String!
  director: String!
  available: Boolean
}

type MovieConnection {
  pageInfo: PageInfo!
  edges: [MovieEdge]!
  aggregate: AggregateMovie!
}

input MovieCreateInput {
  id: ID
  name: String!
  time: Int!
  rates: String!
  director: String!
  available: Boolean
}

input MovieCreateOneInput {
  create: MovieCreateInput
  connect: MovieWhereUniqueInput
}

type MovieEdge {
  node: Movie!
  cursor: String!
}

enum MovieOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  name_ASC
  name_DESC
  time_ASC
  time_DESC
  rates_ASC
  rates_DESC
  director_ASC
  director_DESC
  available_ASC
  available_DESC
}

type MoviePreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  time: Int!
  rates: String!
  director: String!
  available: Boolean
}

type MovieSubscriptionPayload {
  mutation: MutationType!
  node: Movie
  updatedFields: [String!]
  previousValues: MoviePreviousValues
}

input MovieSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MovieWhereInput
  AND: [MovieSubscriptionWhereInput!]
}

input MovieUpdateDataInput {
  name: String
  time: Int
  rates: String
  director: String
  available: Boolean
}

input MovieUpdateInput {
  name: String
  time: Int
  rates: String
  director: String
  available: Boolean
}

input MovieUpdateManyMutationInput {
  name: String
  time: Int
  rates: String
  director: String
  available: Boolean
}

input MovieUpdateOneInput {
  create: MovieCreateInput
  update: MovieUpdateDataInput
  upsert: MovieUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: MovieWhereUniqueInput
}

input MovieUpdateOneRequiredInput {
  create: MovieCreateInput
  update: MovieUpdateDataInput
  upsert: MovieUpsertNestedInput
  connect: MovieWhereUniqueInput
}

input MovieUpsertNestedInput {
  update: MovieUpdateDataInput!
  create: MovieCreateInput!
}

input MovieWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  time: Int
  time_not: Int
  time_in: [Int!]
  time_not_in: [Int!]
  time_lt: Int
  time_lte: Int
  time_gt: Int
  time_gte: Int
  rates: String
  rates_not: String
  rates_in: [String!]
  rates_not_in: [String!]
  rates_lt: String
  rates_lte: String
  rates_gt: String
  rates_gte: String
  rates_contains: String
  rates_not_contains: String
  rates_starts_with: String
  rates_not_starts_with: String
  rates_ends_with: String
  rates_not_ends_with: String
  director: String
  director_not: String
  director_in: [String!]
  director_not_in: [String!]
  director_lt: String
  director_lte: String
  director_gt: String
  director_gte: String
  director_contains: String
  director_not_contains: String
  director_starts_with: String
  director_not_starts_with: String
  director_ends_with: String
  director_not_ends_with: String
  available: Boolean
  available_not: Boolean
  AND: [MovieWhereInput!]
}

input MovieWhereUniqueInput {
  id: ID
  name: String
}

type Mutation {
  createCine(data: CineCreateInput!): Cine!
  updateCine(data: CineUpdateInput!, where: CineWhereUniqueInput!): Cine
  updateManyCines(data: CineUpdateManyMutationInput!, where: CineWhereInput): BatchPayload!
  upsertCine(where: CineWhereUniqueInput!, create: CineCreateInput!, update: CineUpdateInput!): Cine!
  deleteCine(where: CineWhereUniqueInput!): Cine
  deleteManyCines(where: CineWhereInput): BatchPayload!
  createColaborator(data: ColaboratorCreateInput!): Colaborator!
  updateColaborator(data: ColaboratorUpdateInput!, where: ColaboratorWhereUniqueInput!): Colaborator
  updateManyColaborators(data: ColaboratorUpdateManyMutationInput!, where: ColaboratorWhereInput): BatchPayload!
  upsertColaborator(where: ColaboratorWhereUniqueInput!, create: ColaboratorCreateInput!, update: ColaboratorUpdateInput!): Colaborator!
  deleteColaborator(where: ColaboratorWhereUniqueInput!): Colaborator
  deleteManyColaborators(where: ColaboratorWhereInput): BatchPayload!
  createMovie(data: MovieCreateInput!): Movie!
  updateMovie(data: MovieUpdateInput!, where: MovieWhereUniqueInput!): Movie
  updateManyMovies(data: MovieUpdateManyMutationInput!, where: MovieWhereInput): BatchPayload!
  upsertMovie(where: MovieWhereUniqueInput!, create: MovieCreateInput!, update: MovieUpdateInput!): Movie!
  deleteMovie(where: MovieWhereUniqueInput!): Movie
  deleteManyMovies(where: MovieWhereInput): BatchPayload!
  createOrdenDulceria(data: OrdenDulceriaCreateInput!): OrdenDulceria!
  updateOrdenDulceria(data: OrdenDulceriaUpdateInput!, where: OrdenDulceriaWhereUniqueInput!): OrdenDulceria
  updateManyOrdenDulcerias(data: OrdenDulceriaUpdateManyMutationInput!, where: OrdenDulceriaWhereInput): BatchPayload!
  upsertOrdenDulceria(where: OrdenDulceriaWhereUniqueInput!, create: OrdenDulceriaCreateInput!, update: OrdenDulceriaUpdateInput!): OrdenDulceria!
  deleteOrdenDulceria(where: OrdenDulceriaWhereUniqueInput!): OrdenDulceria
  deleteManyOrdenDulcerias(where: OrdenDulceriaWhereInput): BatchPayload!
  createPago(data: PagoCreateInput!): Pago!
  updatePago(data: PagoUpdateInput!, where: PagoWhereUniqueInput!): Pago
  updateManyPagoes(data: PagoUpdateManyMutationInput!, where: PagoWhereInput): BatchPayload!
  upsertPago(where: PagoWhereUniqueInput!, create: PagoCreateInput!, update: PagoUpdateInput!): Pago!
  deletePago(where: PagoWhereUniqueInput!): Pago
  deleteManyPagoes(where: PagoWhereInput): BatchPayload!
  createRoom(data: RoomCreateInput!): Room!
  updateRoom(data: RoomUpdateInput!, where: RoomWhereUniqueInput!): Room
  updateManyRooms(data: RoomUpdateManyMutationInput!, where: RoomWhereInput): BatchPayload!
  upsertRoom(where: RoomWhereUniqueInput!, create: RoomCreateInput!, update: RoomUpdateInput!): Room!
  deleteRoom(where: RoomWhereUniqueInput!): Room
  deleteManyRooms(where: RoomWhereInput): BatchPayload!
  createSeat(data: SeatCreateInput!): Seat!
  updateSeat(data: SeatUpdateInput!, where: SeatWhereUniqueInput!): Seat
  updateManySeats(data: SeatUpdateManyMutationInput!, where: SeatWhereInput): BatchPayload!
  upsertSeat(where: SeatWhereUniqueInput!, create: SeatCreateInput!, update: SeatUpdateInput!): Seat!
  deleteSeat(where: SeatWhereUniqueInput!): Seat
  deleteManySeats(where: SeatWhereInput): BatchPayload!
  createTicket(data: TicketCreateInput!): Ticket!
  updateTicket(data: TicketUpdateInput!, where: TicketWhereUniqueInput!): Ticket
  updateManyTickets(data: TicketUpdateManyMutationInput!, where: TicketWhereInput): BatchPayload!
  upsertTicket(where: TicketWhereUniqueInput!, create: TicketCreateInput!, update: TicketUpdateInput!): Ticket!
  deleteTicket(where: TicketWhereUniqueInput!): Ticket
  deleteManyTickets(where: TicketWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type OrdenDulceria {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  amount: Int!
  items: [String!]!
  Cine: Cine!
  user: User
}

type OrdenDulceriaConnection {
  pageInfo: PageInfo!
  edges: [OrdenDulceriaEdge]!
  aggregate: AggregateOrdenDulceria!
}

input OrdenDulceriaCreateInput {
  id: ID
  amount: Int!
  items: OrdenDulceriaCreateitemsInput
  Cine: CineCreateOneInput!
  user: UserCreateOneInput
}

input OrdenDulceriaCreateitemsInput {
  set: [String!]
}

type OrdenDulceriaEdge {
  node: OrdenDulceria!
  cursor: String!
}

enum OrdenDulceriaOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  amount_ASC
  amount_DESC
}

type OrdenDulceriaPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  amount: Int!
  items: [String!]!
}

type OrdenDulceriaSubscriptionPayload {
  mutation: MutationType!
  node: OrdenDulceria
  updatedFields: [String!]
  previousValues: OrdenDulceriaPreviousValues
}

input OrdenDulceriaSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OrdenDulceriaWhereInput
  AND: [OrdenDulceriaSubscriptionWhereInput!]
}

input OrdenDulceriaUpdateInput {
  amount: Int
  items: OrdenDulceriaUpdateitemsInput
  Cine: CineUpdateOneRequiredInput
  user: UserUpdateOneInput
}

input OrdenDulceriaUpdateitemsInput {
  set: [String!]
}

input OrdenDulceriaUpdateManyMutationInput {
  amount: Int
  items: OrdenDulceriaUpdateitemsInput
}

input OrdenDulceriaWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  amount: Int
  amount_not: Int
  amount_in: [Int!]
  amount_not_in: [Int!]
  amount_lt: Int
  amount_lte: Int
  amount_gt: Int
  amount_gte: Int
  Cine: CineWhereInput
  user: UserWhereInput
  AND: [OrdenDulceriaWhereInput!]
}

input OrdenDulceriaWhereUniqueInput {
  id: ID
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Pago {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  nomina: String!
  pago: Int!
}

type PagoConnection {
  pageInfo: PageInfo!
  edges: [PagoEdge]!
  aggregate: AggregatePago!
}

input PagoCreateInput {
  id: ID
  nomina: String!
  pago: Int!
}

type PagoEdge {
  node: Pago!
  cursor: String!
}

enum PagoOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  nomina_ASC
  nomina_DESC
  pago_ASC
  pago_DESC
}

type PagoPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  nomina: String!
  pago: Int!
}

type PagoSubscriptionPayload {
  mutation: MutationType!
  node: Pago
  updatedFields: [String!]
  previousValues: PagoPreviousValues
}

input PagoSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PagoWhereInput
  AND: [PagoSubscriptionWhereInput!]
}

input PagoUpdateInput {
  nomina: String
  pago: Int
}

input PagoUpdateManyMutationInput {
  nomina: String
  pago: Int
}

input PagoWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  nomina: String
  nomina_not: String
  nomina_in: [String!]
  nomina_not_in: [String!]
  nomina_lt: String
  nomina_lte: String
  nomina_gt: String
  nomina_gte: String
  nomina_contains: String
  nomina_not_contains: String
  nomina_starts_with: String
  nomina_not_starts_with: String
  nomina_ends_with: String
  nomina_not_ends_with: String
  pago: Int
  pago_not: Int
  pago_in: [Int!]
  pago_not_in: [Int!]
  pago_lt: Int
  pago_lte: Int
  pago_gt: Int
  pago_gte: Int
  AND: [PagoWhereInput!]
}

input PagoWhereUniqueInput {
  id: ID
}

type Query {
  cine(where: CineWhereUniqueInput!): Cine
  cines(where: CineWhereInput, orderBy: CineOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Cine]!
  cinesConnection(where: CineWhereInput, orderBy: CineOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CineConnection!
  colaborator(where: ColaboratorWhereUniqueInput!): Colaborator
  colaborators(where: ColaboratorWhereInput, orderBy: ColaboratorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Colaborator]!
  colaboratorsConnection(where: ColaboratorWhereInput, orderBy: ColaboratorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ColaboratorConnection!
  movie(where: MovieWhereUniqueInput!): Movie
  movies(where: MovieWhereInput, orderBy: MovieOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Movie]!
  moviesConnection(where: MovieWhereInput, orderBy: MovieOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MovieConnection!
  ordenDulceria(where: OrdenDulceriaWhereUniqueInput!): OrdenDulceria
  ordenDulcerias(where: OrdenDulceriaWhereInput, orderBy: OrdenDulceriaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [OrdenDulceria]!
  ordenDulceriasConnection(where: OrdenDulceriaWhereInput, orderBy: OrdenDulceriaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OrdenDulceriaConnection!
  pago(where: PagoWhereUniqueInput!): Pago
  pagoes(where: PagoWhereInput, orderBy: PagoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Pago]!
  pagoesConnection(where: PagoWhereInput, orderBy: PagoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PagoConnection!
  room(where: RoomWhereUniqueInput!): Room
  rooms(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Room]!
  roomsConnection(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RoomConnection!
  seat(where: SeatWhereUniqueInput!): Seat
  seats(where: SeatWhereInput, orderBy: SeatOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Seat]!
  seatsConnection(where: SeatWhereInput, orderBy: SeatOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SeatConnection!
  ticket(where: TicketWhereUniqueInput!): Ticket
  tickets(where: TicketWhereInput, orderBy: TicketOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Ticket]!
  ticketsConnection(where: TicketWhereInput, orderBy: TicketOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TicketConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Room {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  number: Int!
  Movie: Movie
  available: Boolean!
}

type RoomConnection {
  pageInfo: PageInfo!
  edges: [RoomEdge]!
  aggregate: AggregateRoom!
}

input RoomCreateInput {
  id: ID
  number: Int!
  Movie: MovieCreateOneInput
  available: Boolean
}

input RoomCreateManyInput {
  create: [RoomCreateInput!]
  connect: [RoomWhereUniqueInput!]
}

input RoomCreateOneInput {
  create: RoomCreateInput
  connect: RoomWhereUniqueInput
}

type RoomEdge {
  node: Room!
  cursor: String!
}

enum RoomOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  number_ASC
  number_DESC
  available_ASC
  available_DESC
}

type RoomPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  number: Int!
  available: Boolean!
}

input RoomScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  number: Int
  number_not: Int
  number_in: [Int!]
  number_not_in: [Int!]
  number_lt: Int
  number_lte: Int
  number_gt: Int
  number_gte: Int
  available: Boolean
  available_not: Boolean
  AND: [RoomScalarWhereInput!]
  OR: [RoomScalarWhereInput!]
  NOT: [RoomScalarWhereInput!]
}

type RoomSubscriptionPayload {
  mutation: MutationType!
  node: Room
  updatedFields: [String!]
  previousValues: RoomPreviousValues
}

input RoomSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RoomWhereInput
  AND: [RoomSubscriptionWhereInput!]
}

input RoomUpdateDataInput {
  number: Int
  Movie: MovieUpdateOneInput
  available: Boolean
}

input RoomUpdateInput {
  number: Int
  Movie: MovieUpdateOneInput
  available: Boolean
}

input RoomUpdateManyDataInput {
  number: Int
  available: Boolean
}

input RoomUpdateManyInput {
  create: [RoomCreateInput!]
  update: [RoomUpdateWithWhereUniqueNestedInput!]
  upsert: [RoomUpsertWithWhereUniqueNestedInput!]
  delete: [RoomWhereUniqueInput!]
  connect: [RoomWhereUniqueInput!]
  set: [RoomWhereUniqueInput!]
  disconnect: [RoomWhereUniqueInput!]
  deleteMany: [RoomScalarWhereInput!]
  updateMany: [RoomUpdateManyWithWhereNestedInput!]
}

input RoomUpdateManyMutationInput {
  number: Int
  available: Boolean
}

input RoomUpdateManyWithWhereNestedInput {
  where: RoomScalarWhereInput!
  data: RoomUpdateManyDataInput!
}

input RoomUpdateOneRequiredInput {
  create: RoomCreateInput
  update: RoomUpdateDataInput
  upsert: RoomUpsertNestedInput
  connect: RoomWhereUniqueInput
}

input RoomUpdateWithWhereUniqueNestedInput {
  where: RoomWhereUniqueInput!
  data: RoomUpdateDataInput!
}

input RoomUpsertNestedInput {
  update: RoomUpdateDataInput!
  create: RoomCreateInput!
}

input RoomUpsertWithWhereUniqueNestedInput {
  where: RoomWhereUniqueInput!
  update: RoomUpdateDataInput!
  create: RoomCreateInput!
}

input RoomWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  number: Int
  number_not: Int
  number_in: [Int!]
  number_not_in: [Int!]
  number_lt: Int
  number_lte: Int
  number_gt: Int
  number_gte: Int
  Movie: MovieWhereInput
  available: Boolean
  available_not: Boolean
  AND: [RoomWhereInput!]
}

input RoomWhereUniqueInput {
  id: ID
  number: Int
}

type Seat {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  Room: Room!
  name: String!
  available: Boolean!
}

type SeatConnection {
  pageInfo: PageInfo!
  edges: [SeatEdge]!
  aggregate: AggregateSeat!
}

input SeatCreateInput {
  id: ID
  Room: RoomCreateOneInput!
  name: String!
  available: Boolean
}

input SeatCreateManyInput {
  create: [SeatCreateInput!]
  connect: [SeatWhereUniqueInput!]
}

type SeatEdge {
  node: Seat!
  cursor: String!
}

enum SeatOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  name_ASC
  name_DESC
  available_ASC
  available_DESC
}

type SeatPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  available: Boolean!
}

input SeatScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  available: Boolean
  available_not: Boolean
  AND: [SeatScalarWhereInput!]
  OR: [SeatScalarWhereInput!]
  NOT: [SeatScalarWhereInput!]
}

type SeatSubscriptionPayload {
  mutation: MutationType!
  node: Seat
  updatedFields: [String!]
  previousValues: SeatPreviousValues
}

input SeatSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SeatWhereInput
  AND: [SeatSubscriptionWhereInput!]
}

input SeatUpdateDataInput {
  Room: RoomUpdateOneRequiredInput
  name: String
  available: Boolean
}

input SeatUpdateInput {
  Room: RoomUpdateOneRequiredInput
  name: String
  available: Boolean
}

input SeatUpdateManyDataInput {
  name: String
  available: Boolean
}

input SeatUpdateManyInput {
  create: [SeatCreateInput!]
  update: [SeatUpdateWithWhereUniqueNestedInput!]
  upsert: [SeatUpsertWithWhereUniqueNestedInput!]
  delete: [SeatWhereUniqueInput!]
  connect: [SeatWhereUniqueInput!]
  set: [SeatWhereUniqueInput!]
  disconnect: [SeatWhereUniqueInput!]
  deleteMany: [SeatScalarWhereInput!]
  updateMany: [SeatUpdateManyWithWhereNestedInput!]
}

input SeatUpdateManyMutationInput {
  name: String
  available: Boolean
}

input SeatUpdateManyWithWhereNestedInput {
  where: SeatScalarWhereInput!
  data: SeatUpdateManyDataInput!
}

input SeatUpdateWithWhereUniqueNestedInput {
  where: SeatWhereUniqueInput!
  data: SeatUpdateDataInput!
}

input SeatUpsertWithWhereUniqueNestedInput {
  where: SeatWhereUniqueInput!
  update: SeatUpdateDataInput!
  create: SeatCreateInput!
}

input SeatWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  Room: RoomWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  available: Boolean
  available_not: Boolean
  AND: [SeatWhereInput!]
}

input SeatWhereUniqueInput {
  id: ID
}

type Subscription {
  cine(where: CineSubscriptionWhereInput): CineSubscriptionPayload
  colaborator(where: ColaboratorSubscriptionWhereInput): ColaboratorSubscriptionPayload
  movie(where: MovieSubscriptionWhereInput): MovieSubscriptionPayload
  ordenDulceria(where: OrdenDulceriaSubscriptionWhereInput): OrdenDulceriaSubscriptionPayload
  pago(where: PagoSubscriptionWhereInput): PagoSubscriptionPayload
  room(where: RoomSubscriptionWhereInput): RoomSubscriptionPayload
  seat(where: SeatSubscriptionWhereInput): SeatSubscriptionPayload
  ticket(where: TicketSubscriptionWhereInput): TicketSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type Ticket {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  seats(where: SeatWhereInput, orderBy: SeatOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Seat!]
  movie: Movie!
  cine: Cine!
  user: User
  price: Int!
  pagoPuntos: Boolean
}

type TicketConnection {
  pageInfo: PageInfo!
  edges: [TicketEdge]!
  aggregate: AggregateTicket!
}

input TicketCreateInput {
  id: ID
  seats: SeatCreateManyInput
  movie: MovieCreateOneInput!
  cine: CineCreateOneInput!
  user: UserCreateOneInput
  price: Int!
  pagoPuntos: Boolean
}

type TicketEdge {
  node: Ticket!
  cursor: String!
}

enum TicketOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  price_ASC
  price_DESC
  pagoPuntos_ASC
  pagoPuntos_DESC
}

type TicketPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  price: Int!
  pagoPuntos: Boolean
}

type TicketSubscriptionPayload {
  mutation: MutationType!
  node: Ticket
  updatedFields: [String!]
  previousValues: TicketPreviousValues
}

input TicketSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TicketWhereInput
  AND: [TicketSubscriptionWhereInput!]
}

input TicketUpdateInput {
  seats: SeatUpdateManyInput
  movie: MovieUpdateOneRequiredInput
  cine: CineUpdateOneRequiredInput
  user: UserUpdateOneInput
  price: Int
  pagoPuntos: Boolean
}

input TicketUpdateManyMutationInput {
  price: Int
  pagoPuntos: Boolean
}

input TicketWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  seats_some: SeatWhereInput
  movie: MovieWhereInput
  cine: CineWhereInput
  user: UserWhereInput
  price: Int
  price_not: Int
  price_in: [Int!]
  price_not_in: [Int!]
  price_lt: Int
  price_lte: Int
  price_gt: Int
  price_gte: Int
  pagoPuntos: Boolean
  pagoPuntos_not: Boolean
  AND: [TicketWhereInput!]
}

input TicketWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  email: String!
  password: String
  name: String!
  points: Int
  cardStatus: Boolean!
  available: Boolean
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  email: String!
  password: String
  name: String!
  points: Int
  cardStatus: Boolean
  available: Boolean
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  name_ASC
  name_DESC
  points_ASC
  points_DESC
  cardStatus_ASC
  cardStatus_DESC
  available_ASC
  available_DESC
}

type UserPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  email: String!
  password: String
  name: String!
  points: Int
  cardStatus: Boolean!
  available: Boolean
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  email: String
  password: String
  name: String
  points: Int
  cardStatus: Boolean
  available: Boolean
}

input UserUpdateInput {
  email: String
  password: String
  name: String
  points: Int
  cardStatus: Boolean
  available: Boolean
}

input UserUpdateManyMutationInput {
  email: String
  password: String
  name: String
  points: Int
  cardStatus: Boolean
  available: Boolean
}

input UserUpdateOneInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  points: Int
  points_not: Int
  points_in: [Int!]
  points_not_in: [Int!]
  points_lt: Int
  points_lte: Int
  points_gt: Int
  points_gte: Int
  cardStatus: Boolean
  cardStatus_not: Boolean
  available: Boolean
  available_not: Boolean
  AND: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`